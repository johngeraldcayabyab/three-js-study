<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <title>Terrain With Water</title>
    <style>
        html, body {
            margin: 0;
            overscroll-behavior: none;
            height: 100%;
            width: 100%;
            font-family: Monaco, monospace;
            font-size: 13px;
        }

        canvas {
            height: 100% !important;
            width: 100% !important;
        }
    </style>
</head>
<body>

<script type="module">
    import * as THREE from '../node_modules/three/build/three.module.js';
    import {createContainer, createRenderer, createStats} from "../src/helpers.js";
    import {OrbitControls} from "../node_modules/three/examples/jsm/controls/OrbitControls.js";
    import {ImprovedNoise} from "../node_modules/three/examples/jsm/math/ImprovedNoise.js";
    import {Water} from "../node_modules/three/examples/jsm/objects/Water.js";
    import {Sky} from '../node_modules/three/examples/jsm/objects/Sky.js';
    import {GUI} from "../node_modules/three/examples/jsm/libs/dat.gui.module.js";

    main();

    function main() {

        let container, renderer, camera, scene, controls, stats;

        let terrainMesh, terrainTexture, waterMesh, sunMesh, cloudMesh;

        const worldWidth = 256, worldDepth = 256, worldHalfWidth = worldWidth / 2, worldHalfDepth = worldDepth / 2;

        const mapWidthHeight = 7500;

        let helper;

        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();

        init();
        animate();

        function init() {
            container = createContainer(container);
            renderer = createRenderer(renderer, container);
            stats = createStats(stats, container);

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xbfd1e5);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 10, 20000);
            controls = new OrbitControls(camera, renderer.domElement);
            controls.minDistance = 1000;
            controls.maxDistance = 10000;
            controls.maxPolarAngle = Math.PI / 2;
            camera.position.y = 4000;
            camera.position.x = 2000;
            camera.position.z = 2000;

            controls.update();

            terrainMesh = createTerrain();
            scene.add(terrainMesh);

            helper = createGeometryHelper();
            scene.add(helper);

            waterMesh = createWater();
            scene.add(waterMesh);

            // cloudMesh = createCloud();
            // scene.add(cloudMesh);

            sunMesh = new THREE.Vector3();

            scene.add(waterMesh);

            const skyMesh = new Sky();
            skyMesh.scale.setScalar(mapWidthHeight);
            scene.add(skyMesh);

            const skyUniforms = skyMesh.material.uniforms;

            skyUniforms['turbidity'].value = 10;
            skyUniforms['rayleigh'].value = 2;
            skyUniforms['mieCoefficient'].value = 0.005;
            skyUniforms['mieDirectionalG'].value = 0.8;

            const parameters = {
                elevation: 2,
                azimuth: 180
            };

            const pmremGenerator = new THREE.PMREMGenerator(renderer);

            function updateSun() {
                const phi = THREE.MathUtils.degToRad(90 - parameters.elevation);
                const theta = THREE.MathUtils.degToRad(parameters.azimuth);
                sunMesh.setFromSphericalCoords(1, phi, theta);
                skyMesh.material.uniforms['sunPosition'].value.copy(sunMesh);
                waterMesh.material.uniforms['sunDirection'].value.copy(sunMesh).normalize();
                scene.environment = pmremGenerator.fromScene(skyMesh).texture;
            }

            updateSun();


            const gui = new GUI();

            const folderSky = gui.addFolder('Sky');
            folderSky.add(parameters, 'elevation', 0, 90, 0.1).onChange(updateSun);
            folderSky.add(parameters, 'azimuth', -180, 180, 0.1).onChange(updateSun);
            folderSky.open();

            const waterUniforms = waterMesh.material.uniforms;

            const folderWater = gui.addFolder('Water');
            folderWater.add(waterUniforms.distortionScale, 'value', 0, 8, 0.1).name('distortionScale');
            folderWater.add(waterUniforms.size, 'value', 0.1, 10, 0.1).name('size');
            folderWater.open();

            container.addEventListener('pointermove', onPointerMove);
            window.addEventListener('resize', onWindowResize);
        }

        function createTerrain() {
            const data = generateTerrainHeight(worldWidth, worldDepth);
            const terrainGeometry = new THREE.PlaneGeometry(mapWidthHeight, mapWidthHeight, worldWidth - 1, worldDepth - 1);
            terrainGeometry.rotateX(-Math.PI / 2);

            const vertices = terrainGeometry.attributes.position.array;

            for (let i = 0, j = 0, l = vertices.length; i < l; i++, j += 3) {
                vertices[j + 1] = data[i] * 10;
            }

            terrainGeometry.computeFaceNormals(); // needed for helper

            terrainTexture = new THREE.CanvasTexture(generateTerrainTexture(data, worldWidth, worldDepth));
            terrainTexture.wrapS = THREE.ClampToEdgeWrapping;
            terrainTexture.wrapT = THREE.ClampToEdgeWrapping;

            return new THREE.Mesh(terrainGeometry, new THREE.MeshBasicMaterial({map: terrainTexture}));
        }

        function createGeometryHelper() {
            const geometryHelper = new THREE.ConeGeometry(20, 100, 3);
            geometryHelper.translate(0, 50, 0);
            geometryHelper.rotateX(Math.PI / 2);
            return new THREE.Mesh(geometryHelper, new THREE.MeshNormalMaterial());
        }

        function createWater() {
            const waterGeometry = new THREE.PlaneGeometry(mapWidthHeight, mapWidthHeight);

            let water = new Water(
                waterGeometry,
                {
                    textureWidth: 512,
                    textureHeight: 512,
                    waterNormals: new THREE.TextureLoader().load('../textures/waternormals.jpg', function (texture) {
                        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                    }),
                    sunDirection: new THREE.Vector3(),
                    sunColor: 0xffffff,
                    waterColor: 0x001e0f,
                    distortionScale: 3.7,
                    fog: scene.fog !== undefined
                }
            );

            water.rotation.x = -Math.PI / 2;
            water.position.y = 250;

            return water;
        }

        function createCloud(){
            const size = 128;
            const data = new Uint8Array( size * size * size );

            let i = 0;
            const scale = 0.05;
            const perlin = new ImprovedNoise();
            const vector = new THREE.Vector3();

            for ( let z = 0; z < size; z ++ ) {
                for ( let y = 0; y < size; y ++ ) {
                    for ( let x = 0; x < size; x ++ ) {
                        const d = 1.0 - vector.set( x, y, z ).subScalar( size / 2 ).divideScalar( size ).length();
                        data[ i ] = ( 128 + 128 * perlin.noise( x * scale / 1.5, y * scale, z * scale / 1.5 ) ) * d * d;
                        i ++;
                    }
                }
            }

            const texture = new THREE.DataTexture3D( data, size, size, size );
            texture.format = THREE.RedFormat;
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.unpackAlignment = 1;

            const vertexShader = /* glsl */`
					in vec3 position;
					uniform mat4 modelMatrix;
					uniform mat4 modelViewMatrix;
					uniform mat4 projectionMatrix;
					uniform vec3 cameraPos;
					out vec3 vOrigin;
					out vec3 vDirection;
					void main() {
						vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
						vOrigin = vec3( inverse( modelMatrix ) * vec4( cameraPos, 1.0 ) ).xyz;
						vDirection = position - vOrigin;
						gl_Position = projectionMatrix * mvPosition;
					}
				`;

            const fragmentShader = /* glsl */`
					precision highp float;
					precision highp sampler3D;
					uniform mat4 modelViewMatrix;
					uniform mat4 projectionMatrix;
					in vec3 vOrigin;
					in vec3 vDirection;
					out vec4 color;
					uniform vec3 base;
					uniform sampler3D map;
					uniform float threshold;
					uniform float range;
					uniform float opacity;
					uniform float steps;
					uniform float frame;
					uint wang_hash(uint seed)
					{
							seed = (seed ^ 61u) ^ (seed >> 16u);
							seed *= 9u;
							seed = seed ^ (seed >> 4u);
							seed *= 0x27d4eb2du;
							seed = seed ^ (seed >> 15u);
							return seed;
					}
					float randomFloat(inout uint seed)
					{
							return float(wang_hash(seed)) / 4294967296.;
					}
					vec2 hitBox( vec3 orig, vec3 dir ) {
						const vec3 box_min = vec3( - 0.5 );
						const vec3 box_max = vec3( 0.5 );
						vec3 inv_dir = 1.0 / dir;
						vec3 tmin_tmp = ( box_min - orig ) * inv_dir;
						vec3 tmax_tmp = ( box_max - orig ) * inv_dir;
						vec3 tmin = min( tmin_tmp, tmax_tmp );
						vec3 tmax = max( tmin_tmp, tmax_tmp );
						float t0 = max( tmin.x, max( tmin.y, tmin.z ) );
						float t1 = min( tmax.x, min( tmax.y, tmax.z ) );
						return vec2( t0, t1 );
					}
					float sample1( vec3 p ) {
						return texture( map, p ).r;
					}
					float shading( vec3 coord ) {
						float step = 0.01;
						return sample1( coord + vec3( - step ) ) - sample1( coord + vec3( step ) );
					}
					void main(){
						vec3 rayDir = normalize( vDirection );
						vec2 bounds = hitBox( vOrigin, rayDir );
						if ( bounds.x > bounds.y ) discard;
						bounds.x = max( bounds.x, 0.0 );
						vec3 p = vOrigin + bounds.x * rayDir;
						vec3 inc = 1.0 / abs( rayDir );
						float delta = min( inc.x, min( inc.y, inc.z ) );
						delta /= steps;

						uint seed = uint( gl_FragCoord.x ) * uint( 1973 ) + uint( gl_FragCoord.y ) * uint( 9277 ) + uint( frame ) * uint( 26699 );
						vec3 size = vec3( textureSize( map, 0 ) );
						float randNum = randomFloat( seed ) * 2.0 - 1.0;
						p += rayDir * randNum * ( 1.0 / size );
						//
						vec4 ac = vec4( base, 0.0 );
						for ( float t = bounds.x; t < bounds.y; t += delta ) {
							float d = sample1( p + 0.5 );
							d = smoothstep( threshold - range, threshold + range, d ) * opacity;
							float col = shading( p + 0.5 ) * 3.0 + ( ( p.x + p.y ) * 0.25 ) + 0.2;
							ac.rgb += ( 1.0 - ac.a ) * d * col;
							ac.a += ( 1.0 - ac.a ) * d;
							if ( ac.a >= 0.95 ) break;
							p += rayDir * delta;
						}
						color = ac;
						if ( color.a == 0.0 ) discard;
					}
				`;

            const geometry = new THREE.BoxGeometry( 500, 500,500 );
            const material = new THREE.RawShaderMaterial( {
                glslVersion: THREE.GLSL3,
                uniforms: {
                    base: { value: new THREE.Color( 0x798aa0 ) },
                    map: { value: texture },
                    cameraPos: { value: new THREE.Vector3() },
                    threshold: { value: 0.25 },
                    opacity: { value: 0.25 },
                    range: { value: 0.1 },
                    steps: { value: 100 },
                    frame: { value: 0 }
                },
                vertexShader,
                fragmentShader,
                side: THREE.BackSide,
                transparent: true
            } );



            let cloud = new THREE.Mesh( geometry, material );
            // cloud.position.y = 6000;
            return cloud;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function generateTerrainHeight(width, height) {
            const size = width * height, data = new Uint8Array(size), perlin = new ImprovedNoise(),
                z = Math.random() * 100;
            let quality = 1;

            for (let j = 0; j < 4; j++) {
                for (let i = 0; i < size; i++) {
                    const x = i % width, y = ~~(i / width);
                    data[i] += Math.abs(perlin.noise(x / quality, y / quality, z) * quality * 1.75);
                }
                quality *= 5;
            }

            return data;
        }

        function generateTerrainTexture(data, width, height) {
            let context, image, imageData, shade;

            const vector3 = new THREE.Vector3(0, 0, 0);

            const sun = new THREE.Vector3(1, 1, 1);
            sun.normalize();

            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;

            context = canvas.getContext('2d');
            context.fillStyle = '#000';
            context.fillRect(0, 0, width, height);

            image = context.getImageData(0, 0, canvas.width, canvas.height);
            imageData = image.data;

            for (let i = 0, j = 0, l = imageData.length; i < l; i += 4, j++) {
                vector3.x = data[j - 2] - data[j + 2];
                vector3.y = 2;
                vector3.z = data[j - width * 2] - data[j + width * 2];
                vector3.normalize();
                shade = vector3.dot(sun);
                imageData[i] = (96 + shade * 128) * (0.5 + data[j] * 0.007);
                imageData[i + 1] = (32 + shade * 96) * (0.5 + data[j] * 0.007);
                imageData[i + 2] = (shade * 96) * (0.5 + data[j] * 0.007);
            }

            context.putImageData(image, 0, 0);

            const canvasScaled = document.createElement('canvas');
            canvasScaled.width = width * 4;
            canvasScaled.height = height * 4;

            context = canvasScaled.getContext('2d');
            context.scale(4, 4);
            context.drawImage(canvas, 0, 0);

            image = context.getImageData(0, 0, canvasScaled.width, canvasScaled.height);
            imageData = image.data;

            for (let i = 0, l = imageData.length; i < l; i += 4) {
                const v = ~~(Math.random() * 5);

                imageData[i] += v;
                imageData[i + 1] += v;
                imageData[i + 2] += v;

            }
            context.putImageData(image, 0, 0);
            return canvasScaled;
        }

        function animate() {
            requestAnimationFrame(animate);
            render();
            stats.update();
        }

        function render() {
            waterMesh.material.uniforms['time'].value += 1.0 / 60.0;


            // cloudMesh.material.uniforms.cameraPos.value.copy( camera.position );
            // cloudMesh.rotation.y = - performance.now() / 7500;
            //
            // cloudMesh.material.uniforms.frame.value ++;

            renderer.render(scene, camera);
        }

        function onPointerMove(event) {
            pointer.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
            pointer.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;
            raycaster.setFromCamera(pointer, camera);

            const intersects = raycaster.intersectObject(terrainMesh);

            if (intersects.length > 0) {
                helper.position.set(0, 0, 0);
                helper.lookAt(intersects[0].face.normal);
                helper.position.copy(intersects[0].point);
            }
        }
    }
</script>

</body>
</html>