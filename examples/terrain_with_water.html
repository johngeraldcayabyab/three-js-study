<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <title>Terrain With Water</title>
    <style>
        html, body {
            margin: 0;
            overscroll-behavior: none;
            height: 100%;
            width: 100%;
            font-family: Monaco, monospace;
            font-size: 13px;
        }

        canvas {
            height: 100% !important;
            width: 100% !important;
        }
    </style>
</head>
<body>

<script type="module">
    import * as THREE from '../node_modules/three/build/three.module.js';
    import {createContainer, createRenderer, createStats} from "../src/helpers.js";
    import {OrbitControls} from "../node_modules/three/examples/jsm/controls/OrbitControls.js";
    import {ImprovedNoise} from "../node_modules/three/examples/jsm/math/ImprovedNoise.js";
    import {Water} from "../node_modules/three/examples/jsm/objects/Water.js";

    main();

    function main() {

        let container, renderer, camera, scene, controls, stats;

        let terrainMesh, terrainTexture;

        const worldWidth = 256, worldDepth = 256, worldHalfWidth = worldWidth / 2, worldHalfDepth = worldDepth / 2;

        const mapWidthHeight = 7500;

        let helper;

        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();

        let water;

        init();
        animate();

        function init() {
            container = createContainer(container);
            renderer = createRenderer(renderer, container);
            stats = createStats(stats, container);

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xbfd1e5);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 10, 20000);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.minDistance = 1000;
            controls.maxDistance = 10000;
            controls.maxPolarAngle = Math.PI / 2;

            const data = generateHeight(worldWidth, worldDepth);

            controls.target.y = data[worldHalfWidth + worldHalfDepth * worldWidth] + 500;
            camera.position.y = controls.target.y + 2000;
            camera.position.x = 2000;
            controls.update();

            const geometry = new THREE.PlaneGeometry(mapWidthHeight, mapWidthHeight, worldWidth - 1, worldDepth - 1);
            geometry.rotateX(-Math.PI / 2);

            const vertices = geometry.attributes.position.array;

            for (let i = 0, j = 0, l = vertices.length; i < l; i++, j += 3) {
                vertices[j + 1] = data[i] * 10;
            }

            geometry.computeFaceNormals(); // needed for helper


            terrainTexture = new THREE.CanvasTexture(generateTexture(data, worldWidth, worldDepth));
            terrainTexture.wrapS = THREE.ClampToEdgeWrapping;
            terrainTexture.wrapT = THREE.ClampToEdgeWrapping;

            terrainMesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({map: terrainTexture}));
            scene.add(terrainMesh);

            const geometryHelper = new THREE.ConeGeometry(20, 100, 3);
            geometryHelper.translate(0, 50, 0);
            geometryHelper.rotateX(Math.PI / 2);
            helper = new THREE.Mesh(geometryHelper, new THREE.MeshNormalMaterial());
            scene.add(helper)


            const waterGeometry = new THREE.PlaneGeometry(mapWidthHeight, mapWidthHeight);

            water = new Water(
                waterGeometry,
                {
                    textureWidth: 512,
                    textureHeight: 512,
                    waterNormals: new THREE.TextureLoader().load('../textures/waternormals.jpg', function (texture){
                        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                    }),
                    sunDirection: new THREE.Vector3(),
                    sunColor: 0xffffff,
                    waterColor: 0x001e0f,
                    distortionScale: 3.7,
                    fog: scene.fog !== undefined
                }
            );

            scene.add(water);

            water.rotation.x = - Math.PI / 2;
            water.position.y = 250;

            container.addEventListener('pointermove', onPointerMove);

            window.addEventListener('resize', onWindowResize);

        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

        }

        function generateHeight(width, height) {

            const size = width * height, data = new Uint8Array(size),
                perlin = new ImprovedNoise(), z = Math.random() * 100;

            let quality = 1;

            for (let j = 0; j < 4; j++) {

                for (let i = 0; i < size; i++) {

                    const x = i % width, y = ~~(i / width);
                    data[i] += Math.abs(perlin.noise(x / quality, y / quality, z) * quality * 1.75);

                }

                quality *= 5;

            }

            return data;

        }

        function generateTexture(data, width, height) {

            // bake lighting into texture

            let context, image, imageData, shade;

            const vector3 = new THREE.Vector3(0, 0, 0);

            const sun = new THREE.Vector3(1, 1, 1);
            sun.normalize();

            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;

            context = canvas.getContext('2d');
            context.fillStyle = '#000';
            context.fillRect(0, 0, width, height);

            image = context.getImageData(0, 0, canvas.width, canvas.height);
            imageData = image.data;

            for (let i = 0, j = 0, l = imageData.length; i < l; i += 4, j++) {

                vector3.x = data[j - 2] - data[j + 2];
                vector3.y = 2;
                vector3.z = data[j - width * 2] - data[j + width * 2];
                vector3.normalize();

                shade = vector3.dot(sun);

                imageData[i] = (96 + shade * 128) * (0.5 + data[j] * 0.007);
                imageData[i + 1] = (32 + shade * 96) * (0.5 + data[j] * 0.007);
                imageData[i + 2] = (shade * 96) * (0.5 + data[j] * 0.007);

            }

            context.putImageData(image, 0, 0);

            // Scaled 4x

            const canvasScaled = document.createElement('canvas');
            canvasScaled.width = width * 4;
            canvasScaled.height = height * 4;

            context = canvasScaled.getContext('2d');
            context.scale(4, 4);
            context.drawImage(canvas, 0, 0);

            image = context.getImageData(0, 0, canvasScaled.width, canvasScaled.height);
            imageData = image.data;

            for (let i = 0, l = imageData.length; i < l; i += 4) {

                const v = ~~(Math.random() * 5);

                imageData[i] += v;
                imageData[i + 1] += v;
                imageData[i + 2] += v;

            }

            context.putImageData(image, 0, 0);

            return canvasScaled;

        }

        //

        function animate() {

            requestAnimationFrame(animate);

            render();
            stats.update();

        }

        function render() {

            renderer.render(scene, camera);

        }

        function onPointerMove(event) {

            pointer.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
            pointer.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;
            raycaster.setFromCamera(pointer, camera);

            // See if the ray from the camera into the world hits one of our meshes
            const intersects = raycaster.intersectObject(terrainMesh);

            // Toggle rotation bool for meshes that we clicked
            if (intersects.length > 0) {

                helper.position.set(0, 0, 0);
                helper.lookAt(intersects[0].face.normal);

                helper.position.copy(intersects[0].point);

            }

        }
    }
</script>

</body>
</html>