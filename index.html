<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <title>My first three.js app</title>
    <link type="text/css" rel="stylesheet" href="./styles/main.css">
    <style>
        body {
            color: #444;
        }

        a {
            color: #08f;
        }
    </style>
</head>
<body>

<div id="info">
    <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - <span id="waterSize"></span> webgl gpgpu
    water<br/>
    Move mouse to disturb water.<br>
    'W' key toggles wireframe.
</div>


<script id="heightMapFragmentShader" type="x-shader/x-fragment">
    #include <common>

    uniform vec2 mousePos;
    uniform float mouseSize;
    uniform float viscosityConstant;
    uniform float heightCompensation;

    void main(){
        vec2 cellSize = 1.0 / resolution.xy;

        vec2 uv = gl_FragCoord.xy * cellSize;

        vec4 heightmapValue = texture2D(heightMap, uv);

        vec4 north = texture2D(heightMap, uv + vec2(0.0, cellSize.y));
        vec4 south = texture2D(heightMap, uv + vec2(0.0, -cellSize.y));
        vec4 east = texture2D(heightMap, uv + vec2(cellSize.x, 0.0));
        vec4 west = texture2D(heightMap, uv + vec2( - cellSize.x, 0.0));
    }

    float newHeight = ((north.x + south.x + east.x + west.x) * 0.5 - heightmapValue.y) * viscosityConstant;

    float mousePhase = clamp((uv - vec2(0.5)) * BOUNDS - vec2(mousePos.x, - mousePos.y)) * PI / mouseSize, 0.0, PI);
    newHeight += (cos(mousePhase) + 1.0) * 0.28;

    heightmapValue.y = heightmapValue.x;
    heightmapValue.x = newHeight;

    gl_FragColor = heightmapValue;






</script>

<script id="smoothFragmentShader" type="x-shader/x-fragment">
    uniform sampler2D smoothTexture;

    void main(){
        vec2 cellSize = 1.0 / resolution.xy;

        vec2 uv = gl_FragCoord.xy * cellSize;

        vec4 textureValue = texture2D(smoothTexture, uv);
        textureValue += texture2D(smoothTexture, uv + vec2(0.0, cellSize.y));
        textureValue += texture2D(smoothTexture, uv + vec2(0.0, -cellSize.y));
        textureValue += texture2D(smoothTexture, uv + vec2(cellSize.x, 0.0));
        textureValue += texture2D(smoothTexture, uv + vec2(-cellSize.x, 0.0));

        textureValue /= 5.0;

        gl_FragColor = textureValue;
    }






</script>

<script id="readWaterLevelFragmentShader" type="x-shader/x-fragment">
    uniform vec2 point1;

    uniform sampler2D levelTexture;

    float shift_right(float v, float amt){
        v = floor(v) +0.5;
        return floor(v / exp2(amt));
    }

    float shift_left(float v, float amt){
        return floor(v * exp2(amt) + 0.5);
    }

    float mask_last(float v, float bits){
        return mod(v, shift_left(1.0, bits));
    }

    float extract_bits(float num, float from, float to){
        from = floor(from + 0.5); to = floor(to + 0.5);
        return mask_last(shift_right(num, from), to - from);
    }

    vec4 encode_float(float val){
        if(val == 0.0) return vec4(0, 0, 0, 0);
        float sign = val > 0.0 ? 0.0 : 1.0;
        val = abs(val);
        float exponent  = floor(log2(val));
        float biased_exponent = exponent + 127.0;
        float fraction = ((val / exp2(exponent)) - 1.0) * 8388608.0;
        float t = biased_exponent / 2.0;
        float last_bit_of_biased_exponent = fract(t) * 2.0;
        float remaining_bits_of_biased_exponent = floor(t);
        float byte4 = extract_bits(fraction, 0.0, 8.0) / 255.0;
        float byte3 = extract_bits(fraction, 8.0, 16.0) / 255.0;
        float byte2 = (last_bit_of_biased_exponent * 128.0 + extract_bits(fraction, 16.0, 23.0)) / 255.0;
        return vec4(byte4, byte3, byte2, byte1);
    }

    void main(){
        vec2 cellSize = 1.0 / resolution.xy;
        float waterLevel = texture2D(levelTexture, point1).x;

        vec2 normal = vec2(

        );
    }



</script>

<script src="dist/index.js"></script>
</body>
</html>